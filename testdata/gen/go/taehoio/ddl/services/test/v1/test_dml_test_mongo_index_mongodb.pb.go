// Code generated by protoc-gen-go-ddl. DO NOT EDIT.
// versions:
//  protoc-gen-go-ddl v0.0.1-alpha
//  protoc            (unknown)
// source: taehoio/ddl/services/test/v1/test.proto

package testv1

import (
	"context"
	"errors"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

//go:generate mockgen -package testv1 -self_package "github.com/taehoio/protoc-gen-go-ddl/gen/go/ddl/services/test/v1" -source ./test_dml_test_mongo_index_mongodb.pb.go -destination ./test_dml_test_mongo_index_mongodb_mock.pb.go -mock_names TestMongoIndexRecorder=MockTestMongoIndexRecorder "github.com/taehoio/protoc-gen-go-ddl/gen/go/ddl/services/test/v1" TestMongoIndexRecorder

const (
	testMongoIndexCollectionName = "test_mongo_index"
)

var (
	_ strconv.NumError
	_ time.Time
	_ bson.M
	_ primitive.DateTime
	_ proto.Message
	_ timestamppb.Timestamp
)

type TestMongoIndexRecorder interface {
	Get(ctx context.Context, db *mongo.Database, id string) (*TestMongoIndex, error)
	List(ctx context.Context, db *mongo.Database) ([]*TestMongoIndex, error)
	FindByIDs(ctx context.Context, db *mongo.Database, ids []string) ([]*TestMongoIndex, error)
	Save(ctx context.Context, db *mongo.Database, message *TestMongoIndex) error
	Delete(ctx context.Context, db *mongo.Database, id string) error
	FindOneByDeletedAtAndField1(ctx context.Context, db *mongo.Database, field1 uint64) (*TestMongoIndex, error)
	FindByDeletedAtAndField1(ctx context.Context, db *mongo.Database, field1 uint64) ([]*TestMongoIndex, error)
	FindOneByField4AndField3AndField2AndField1(ctx context.Context, db *mongo.Database, field4StartTime *time.Time, field4EndTime *time.Time, field3StartTime *time.Time, field3EndTime *time.Time, field2 *string, field1 uint64) (*TestMongoIndex, error)
	FindByField4AndField3AndField2AndField1(ctx context.Context, db *mongo.Database, field4StartTime *time.Time, field4EndTime *time.Time, field3StartTime *time.Time, field3EndTime *time.Time, field2 *string, field1 uint64) ([]*TestMongoIndex, error)
}

var _ TestMongoIndexRecorder = (*TestMongoIndex)(nil)

func (m *TestMongoIndex) Get(ctx context.Context, db *mongo.Database, id string) (*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)
	return m.get(ctx, coll, id)
}

func (m *TestMongoIndex) List(ctx context.Context, db *mongo.Database) ([]*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	cursor, err := coll.Find(ctx, bson.D{{"deleted_at", nil}})
	if err != nil {
		return nil, err
	}

	var docs []*testMongoIndexDocument
	if err := cursor.All(ctx, &docs); err != nil {
		return nil, err
	}

	pb, err := testMongoIndexDocumentsToProto(docs)
	if err != nil {
		return nil, err
	}

	return pb, nil
}

func (m *TestMongoIndex) FindByIDs(ctx context.Context, db *mongo.Database, ids []string) ([]*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	filter := bson.D{{"$and", bson.A{
		bson.D{{Key: "id", Value: bson.D{{Key: "$in", Value: ids}}}},
		bson.D{{Key: "deleted_at", Value: nil}},
	}}}

	cursor, err := coll.Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	var docs []*testMongoIndexDocument
	if err := cursor.All(ctx, &docs); err != nil {
		return nil, err
	}

	pb, err := testMongoIndexDocumentsToProto(docs)
	if err != nil {
		return nil, err
	}

	return pb, nil
}

func (m *TestMongoIndex) Save(ctx context.Context, db *mongo.Database, message *TestMongoIndex) error {
	if message.Id == "" {
		return ErrIDNotExist
	}

	coll := db.Collection(testMongoIndexCollectionName)

	stored, err := m.get(ctx, coll, message.Id)
	if err != nil && !errors.Is(err, ErrNotFound) {
		return err
	}

	if stored == nil {
		if err := m.insert(ctx, coll, message); err != nil {
			return err
		}
	} else {
		message.CreatedAt = stored.CreatedAt
		if err := m.update(ctx, coll, message); err != nil {
			return err
		}
	}

	return nil
}

func (m *TestMongoIndex) Delete(ctx context.Context, db *mongo.Database, id string) error {
	coll := db.Collection(testMongoIndexCollectionName)

	now := time.Now()
	filter := bson.D{{Key: "id", Value: id}}
	value := bson.D{{Key: "$set", Value: bson.D{{
		Key:   "deleted_at",
		Value: primitive.NewDateTimeFromTime(now)}},
	}}
	if _, err := coll.UpdateOne(ctx, filter, value); err != nil {
		return err
	}
	return nil
}

func (m *TestMongoIndex) FindOneByDeletedAtAndField1(ctx context.Context, db *mongo.Database, field1 uint64) (*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	var andFilter bson.A
	andFilter = append(andFilter, bson.D{{Key: "field1", Value: strconv.FormatUint(field1, 10)}})
	andFilter = append(andFilter, bson.D{{Key: "deleted_at", Value: nil}})

	var doc testMongoIndexDocument
	if err := coll.FindOne(ctx, bson.D{{Key: "$and", Value: andFilter}}).Decode(&doc); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, ErrNotFound
		}
		return nil, err
	}

	return doc.toProto()
}

func (m *TestMongoIndex) FindByDeletedAtAndField1(ctx context.Context, db *mongo.Database, field1 uint64) ([]*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	var andFilter bson.A
	andFilter = append(andFilter, bson.D{{Key: "field1", Value: strconv.FormatUint(field1, 10)}})
	andFilter = append(andFilter, bson.D{{Key: "deleted_at", Value: nil}})

	cursor, err := coll.Find(ctx, bson.D{{Key: "$and", Value: andFilter}})
	if err != nil {
		return nil, err
	}

	var docs []*testMongoIndexDocument
	if err := cursor.All(ctx, &docs); err != nil {
		return nil, err
	}

	return testMongoIndexDocumentsToProto(docs)
}

func (m *TestMongoIndex) FindOneByField4AndField3AndField2AndField1(ctx context.Context, db *mongo.Database, field4StartTime *time.Time, field4EndTime *time.Time, field3StartTime *time.Time, field3EndTime *time.Time, field2 *string, field1 uint64) (*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	var andFilter bson.A
	if field4StartTime != nil && field4EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "$and", Value: bson.A{
			bson.D{{Key: "field4", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field4StartTime)}}}},
			bson.D{{Key: "field4", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field4EndTime)}}}},
		}}})
	} else if field4StartTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field4", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field4StartTime)}}}})
	} else if field4EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field4", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field4EndTime)}}}})
	}
	if field3StartTime != nil && field3EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "$and", Value: bson.A{
			bson.D{{Key: "field3", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field3StartTime)}}}},
			bson.D{{Key: "field3", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field3EndTime)}}}},
		}}})
	} else if field3StartTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field3", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field3StartTime)}}}})
	} else if field3EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field3", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field3EndTime)}}}})
	}
	andFilter = append(andFilter, bson.D{{Key: "field2", Value: field2}})
	andFilter = append(andFilter, bson.D{{Key: "field1", Value: strconv.FormatUint(field1, 10)}})
	andFilter = append(andFilter, bson.D{{Key: "deleted_at", Value: nil}})

	var doc testMongoIndexDocument
	if err := coll.FindOne(ctx, bson.D{{Key: "$and", Value: andFilter}}).Decode(&doc); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, ErrNotFound
		}
		return nil, err
	}

	return doc.toProto()
}

func (m *TestMongoIndex) FindByField4AndField3AndField2AndField1(ctx context.Context, db *mongo.Database, field4StartTime *time.Time, field4EndTime *time.Time, field3StartTime *time.Time, field3EndTime *time.Time, field2 *string, field1 uint64) ([]*TestMongoIndex, error) {
	coll := db.Collection(testMongoIndexCollectionName)

	var andFilter bson.A
	if field4StartTime != nil && field4EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "$and", Value: bson.A{
			bson.D{{Key: "field4", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field4StartTime)}}}},
			bson.D{{Key: "field4", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field4EndTime)}}}},
		}}})
	} else if field4StartTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field4", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field4StartTime)}}}})
	} else if field4EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field4", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field4EndTime)}}}})
	}
	if field3StartTime != nil && field3EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "$and", Value: bson.A{
			bson.D{{Key: "field3", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field3StartTime)}}}},
			bson.D{{Key: "field3", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field3EndTime)}}}},
		}}})
	} else if field3StartTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field3", Value: bson.D{{Key: "$gte", Value: primitive.NewDateTimeFromTime(*field3StartTime)}}}})
	} else if field3EndTime != nil {
		andFilter = append(andFilter, bson.D{{Key: "field3", Value: bson.D{{Key: "$lte", Value: primitive.NewDateTimeFromTime(*field3EndTime)}}}})
	}
	andFilter = append(andFilter, bson.D{{Key: "field2", Value: field2}})
	andFilter = append(andFilter, bson.D{{Key: "field1", Value: strconv.FormatUint(field1, 10)}})
	andFilter = append(andFilter, bson.D{{Key: "deleted_at", Value: nil}})

	cursor, err := coll.Find(ctx, bson.D{{Key: "$and", Value: andFilter}})
	if err != nil {
		return nil, err
	}

	var docs []*testMongoIndexDocument
	if err := cursor.All(ctx, &docs); err != nil {
		return nil, err
	}

	return testMongoIndexDocumentsToProto(docs)
}

func (m *TestMongoIndex) get(ctx context.Context, coll *mongo.Collection, id string) (*TestMongoIndex, error) {
	filter := bson.D{{Key: "$and", Value: bson.A{
		bson.D{{Key: "id", Value: id}},
		bson.D{{Key: "deleted_at", Value: nil}},
	}}}

	var doc testMongoIndexDocument
	if err := coll.FindOne(ctx, filter).Decode(&doc); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, ErrNotFound
		}
		return nil, err
	}

	pb, err := doc.toProto()
	if err != nil {
		return nil, err
	}

	return pb, nil
}

func (m *TestMongoIndex) insert(ctx context.Context, coll *mongo.Collection, message *TestMongoIndex) error {
	now := timestamppb.Now()
	if message.CreatedAt == nil {
		message.CreatedAt = now
	}
	message.UpdatedAt = now

	if _, err := coll.InsertOne(ctx, testMongoIndexDocumentFromProto(message)); err != nil {
		if mongo.IsDuplicateKeyError(err) {
			return ErrDuplicateEntry
		}
		return err
	}

	return nil
}

func (m *TestMongoIndex) update(ctx context.Context, coll *mongo.Collection, message *TestMongoIndex) error {
	message.UpdatedAt = timestamppb.Now()

	filter := bson.D{{Key: "id", Value: message.Id}}
	value := bson.D{{Key: "$set", Value: testMongoIndexDocumentFromProto(message)}}
	if _, err := coll.UpdateOne(ctx, filter, value); err != nil {
		return err
	}

	return nil
}

func testMongoIndexDocumentsToProto(docs []*testMongoIndexDocument) ([]*TestMongoIndex, error) {
	result := make([]*TestMongoIndex, len(docs))

	for i, doc := range docs {
		pb, err := doc.toProto()
		if err != nil {
			return nil, err
		}
		result[i] = pb
	}

	return result, nil
}

type testMongoIndexDocument struct {
	Id        string              `bson:"id"`
	CreatedAt primitive.DateTime  `bson:"created_at"`
	UpdatedAt primitive.DateTime  `bson:"updated_at"`
	DeletedAt *primitive.DateTime `bson:"deleted_at"`
	Field1    string              `bson:"field1"`
	Field2    *string             `bson:"field2"`
	Field3    primitive.DateTime  `bson:"field3"`
	Field4    *primitive.DateTime `bson:"field4"`
}

func (doc *testMongoIndexDocument) toProto() (*TestMongoIndex, error) {
	if doc == nil {
		return nil, nil
	}

	result := &TestMongoIndex{
		Id:        doc.Id,
		CreatedAt: timestamppb.New(doc.CreatedAt.Time()),
		UpdatedAt: timestamppb.New(doc.UpdatedAt.Time()),
		Field2:    doc.Field2,
		Field3:    timestamppb.New(doc.Field3.Time()),
	}

	if doc.DeletedAt != nil {
		result.DeletedAt = timestamppb.New(doc.DeletedAt.Time())
	}

	if u64, err := strconv.ParseUint(doc.Field1, 10, 64); err != nil {
		return nil, err
	} else {
		result.Field1 = u64
	}

	if doc.Field4 != nil {
		result.Field4 = timestamppb.New(doc.Field4.Time())
	}

	return result, nil
}

func testMongoIndexDocumentFromProto(pb *TestMongoIndex) *testMongoIndexDocument {
	if pb == nil {
		return nil
	}

	result := &testMongoIndexDocument{
		Id:        pb.Id,
		CreatedAt: primitive.NewDateTimeFromTime(pb.CreatedAt.AsTime()),
		UpdatedAt: primitive.NewDateTimeFromTime(pb.UpdatedAt.AsTime()),
		Field1:    strconv.FormatUint(pb.Field1, 10),
		Field2:    pb.Field2,
		Field3:    primitive.NewDateTimeFromTime(pb.Field3.AsTime()),
	}

	if pb.DeletedAt != nil {
		deletedAt := primitive.NewDateTimeFromTime(pb.DeletedAt.AsTime())
		result.DeletedAt = &deletedAt
	}

	if pb.Field4 != nil {
		field4 := primitive.NewDateTimeFromTime(pb.Field4.AsTime())
		result.Field4 = &field4
	}

	return result
}
